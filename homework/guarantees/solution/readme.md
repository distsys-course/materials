# Описание решения

## INFO-1
Отправитель отправляет все сообщения, получатель фильтрует сообщения по уникальности.

## INFO-2
Отправитель отправляет все сообщения с уникальным идентификатором (для простоты взят порядковый номер, но достаточно, например, хеша или UUID.). На каждой итерации отправитель перепосылает все сообщения, которые ещё не получили ACK.

Получатель пересылает TestServer все сообщения, а также отправляет ACK отправителю на каждое сообщение.

## INFO-3
Отправитель фильтрует сообщения и делает то же самое, что отправитель INFO-2.

Получатель фильтрует сообщения и пересылает уникальные сообщения TestServer в порядке получения (случайном), а также посылает ACK отправителю на каждое сообщение.

## INFO-4
Отправитель совпадает с INFO-3.
(С замечанием, что в этом случае в headers _необходимо_ передавать порядковый номер, тогда как в INFO-3 достаточно отправлять любой уникальный идентификатор, например, хеш.)

Получатель буферизует сообщения и отправляет их на TestServer по-порядку, то есть отправляет сообщение с номером N, только если он уже получил и отправил все сообщения с номерами < N.

Вначале попробовала написать буферизацию на стороне отправителя и изначально отправку в правильном порядке, получилось корректно, но очень долго, т.к. нельзя выставить таймаут меньше секунды: `self._comm.recv(1)`, а хочется понимать, когда сообщений от TestServer уже не будет и можно начать высылать сообщения. Хотела бы узнать, как сделать буферизацию на клиенте правильно и быстро.
